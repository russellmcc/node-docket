#~readme.out~ 
## docket 
#
# _minimalist documentation generator_
#
# [github](http://github.com/ghostfact/node-docket)
#
# *docket* is a tool I created for myself which lets one easily extract 
# github-flavored-markdown from source code.  It isn't particularly smart
# and it doesn't try to do too much, but it's easy to use.  The simple idea 
# is that you should put your documentation in the same place as your code.
#
# The implementation is inspired and uses some code by `docco`.
#
# ## Sections
# To make a section of comments visible to *docket*, use a named header
# bracketed with tildes(`~`).  for example, 
#
#       //~demosection~
#       // Blah!
#
# would begin a section called `demosection` in javascript.  The section will
# continue until there is a line that is not a comment (i.e., either code or whitespace).
# In this case, the `demosection` would contain the text `" Blah"`.  The tilde can
# be changed to any other symbol or pair of symbols via the `-b` command line option.
#

#~readme.out~
# #### Re-opening sections
# Sections can be re-opened at any time, that is if you, at a later point in the file,
# added the line
#
#       //~demosection~
#       // More blah!
#
# Any comments after that line would be put in the same section as the first comment.  
# `demosection` would now contain `" Blah!\n More blah!"`
#
# #### Output sections
# Any sections whose name ends in `.out` will be output into docket's base directory,
# that is the current directory or the directory specified with the `-d` command line option.
# By default the output will be in html generated by interpretting the section text as markdown, 
# but with the `-m` option you can output the raw markdown.  We use the same github-flavored-markdown
# as docco.
#
# #### Verbatim sections
#
# sections whose name begins with `verbatim:` are special in that the rest of the file,
# code and all, are added to the section.
#
# #### Ordered sections
#
# Across several files, there are no guarentees about the order files are added to sections.
# To ensure a particular ordering, use square brackets `[]` at the end of the section name.
# e.g:
#
# ~ordereddemo~
#
#  The tokens inside the square brackets are sorted in lexicographic order.
#
# #### References 
#
# ~referenceinfo~

#~ordereddemo[b]~
#
#       //~ordered[b]~
#       // this happens second
#

#~ordereddemo[a]~
#
#       //~ordered[a]~
#       // this happens first
#

# ~referenceinfo~
# While a section is open, any tilded identifiers become references to other sections.
# after all the input files are parsed, the references are filled in with the text
# of the referenced section.  For example,
#
#       //~containersection~
#       //~subsection~
#
#       //.. stuff goes here
#       //~subsection~
#       //info!
#
# Would cause `~containersection~` to contain `"info!"`.  If the referenced section
# is never defined, no replacement is made.  References can be nested arbitrarily
# but behavior is undefined if there is a reference loop (i.e. a section references itself).
#
# ~licenseinfo~

#~licenseinfo~
# `docket` is released under a permissive license, but it uses some code and ideas from
# `docco`, which is under the MIT license.

fs = require "fs"
path = require "path"
showdown = require('./../vendor/showdown').Showdown
child = require 'child_process'

## Configurable, global options
# The _Section Brackets_ are used by docket to parse _Section Identifiers_
section_lbracket = '~'
section_rbracket = '~'

# should we be making html?
html_mode = false
# should we be making .md?
md_mode = false

base_dir = ""

## Implementation

# `section_identifer` is a regex that matches _Section Identifiers_.  
# It's given in string form for easy composition
section_identifier = -> section_lbracket + "([^\\s]*)" + section_rbracket

# `section_header` is a regex that matches _Section Headers_, that is
# _Section Identifiers_ alone on a line.
section_header = -> "^\\s?" + section_identifier() + "\\s?$"

# we use a `language` object to store information about languages.
language = (name, comment_symbol) ->
    @name = name
    @comment_symbol = comment_symbol
    
# information shared between all languages
language.prototype =
    
    # `get_comment` takes a line of text and outputs a comment string or `null`
    # if there is no comment on that line.
    # following `docco`, we only accept single line comments that are not
    # preceded by text.
    get_comment : (line) ->
        # if the `@comment_symbol` is `''`, that means that all lines should be
        # treated as comments.
        return line if @comment_symbol is ''
        
        # otherwise, match anything after the comment symbol when
        # the comment symbol is at the start of the line. 
        comment_regex = new RegExp "^\\s?#{@comment_symbol}\\s?(.*)\\s?$"
        (comment_regex.exec line)?[1]

# This is the array of actual languages supported.  If you want more, add them 
# here.
languages =
  '.coffee': new language 'coffee-script', '#'
  '.js': new language 'javascript', '//'
  '.md': new language 'markdown', ''
  
# This looks up the extention in the languages array.
get_language = (sourcepath) -> 
  languages[path.extname(sourcepath)] ? new language 'unknown', ''

# `parse_text` reads text `text` as `language` `lang`, and adds each 
# contained _Docket Section_ to the object `sections`
parse_text = (path, text, sections) ->
  lang = get_language path
  curr_section = null
  verbatim = false
  in_code = false
  for line in text.split '\n'
    # for each line in the file, try to grab a comment.
    comment = lang.get_comment line
    if not comment?
      if not verbatim
        curr_section = null
      else
        if not in_code
          in_code = true
          sections[curr_section].text += if html_mode then "\n" else "```#{lang.name}\n"
        sections[curr_section].text += (if html_mode then "        " else "") + "#{line}\n"
    else
      if curr_section?
        if in_code and verbatim
          in_code = false
          sections[curr_section].text += if html_mode then '\n' else '```\n'
          
        # if we run into any _Section Identifiers_ while in a section,
        # these must be references.
        section_id_regex = (new RegExp section_identifier(), "g")
        while section_id = section_id_regex.exec comment
          sections[curr_section].refs.push section_id[1]
        # add the comment to the section.
        sections[curr_section].text += comment + "\n"
      else
        # check if this is a _Section Header_, and if so, enter that section
        header_regex = new RegExp section_header()
        header = header_regex.exec comment
        curr_section = header?[1]
        if curr_section?
          if (/^verbatim:/.exec curr_section)
            verbatim = true
            curr_section = curr_section.replace /^verbatim:/, ""
          if not sections[curr_section]?
            sections[curr_section] = {text : "", refs : []} if not sections[curr_section]?
          else
            sections[curr_section].text += "\n"
  if verbatim and in_code and not html_mode
    sections[curr_section].text += '```\n'

  sections

# `read_file` reads a file at path `path` and adds all of its sections to `sections`
read_file = (path, sections, callback) ->
  fs.readFile path, "utf8", (error, text) ->
    throw error if error
    sections = parse_text path, text, sections
    callback?(sections)
    
# `fill_references` fills in all references to sections in each section.
fill_references = (sections, roots) ->
  filled_sections = {}
  
  # first step is to parse out the ordered sections.
  for title, sec of sections
    if (unordered = (/^(.*)\[.*\]$/.exec title)?[1])?
      sections[unordered] = sections[unordered] ? {refs : [], text : ""}
      sections[unordered].text = "#{sec.text}" + sections[unordered].text
      sections[unordered].refs += sec.refs
    
  fill_section = (title, {text, refs}, parents, filled) ->
    return filled if filled[title]?

    # don't do any substitution if we detect recursion.  
    for parent in parents
      if parent is title
        filled[title] = "#{section_lbracket}#{title}#{section_rbracket}"
        return filled
        
    parents = parents[0...parents.length]
    parents.push title

    # ensure references are filled before we plug them in.
    for ref in refs
      if sections[ref]?
        filled = fill_section ref, sections[ref], parents, filled
        text = text.replace "#{section_lbracket}#{ref}#{section_rbracket}", filled[ref]
        
    filled[title] = text
    filled

  for title, section of sections
    filled_sections = fill_section title, section, [], filled_sections
 
  filled_sections

# The CSS styles we'd like to apply to the documentation.
docket_styles    = fs.readFileSync(__dirname + '/../resources/docket.css').toString()

# `ensure_directory` ensures that the destination directory exists.
ensure_directory = (srcpath, callback) ->
  dirname = path.dirname srcpath
  child.exec "mkdir -p #{dirname}", ->
    # first, copy in the css
    fs.writeFile dirname + "/docket.css", docket_styles if html_mode
    callback()

# get an html header for a file.
get_html = (title, html) ->
    """
<head>
  <title>#{title}</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <link rel="stylesheet" media="all" href="docket.css" />
</head>
<body>
  <table cellpadding="0" cellspacing="0">
      <tbody><tr><td class="docs">#{html}</td></tr></tbody>
  </table>
</body>
    """

# this is a helper that calls read file repeatedly on a number
# of files.
read_files = (paths) -> (sections) ->
  if paths.length
    read_file paths[0], sections, read_files paths[1...paths.length]
  else
    # finished all the paths - now we have to fill in all references
    sections = fill_references(sections)
    
    # the outputs are any sections that have the ".out" extension.
    for title, text of sections
      if (/\.out$/.exec title)
       do (title, text) ->
         ensure_directory (path.join base_dir,title), ->
          if md_mode
            fs.writeFile (path.join base_dir,title.replace /\.out$/, ".md"), text
          if html_mode
            fs.writeFile (path.join base_dir,title.replace /\.out$/, ".html"), get_html (/\/(.*).html$/.exec title)?[1] ? title, (showdown.makeHtml text)
        
exports.perform = (paths, options) ->
  section_lbracket = options?.brackets?[0] ? section_lbracket
  section_rbracket = options?.brackets?[1] ? section_rbracket
  html_mode = options?.html ? html_mode
  base_dir = options?["base-dir"] ? base_dir
  md_mode = options?.markdown ? md_mode
  (read_files paths) {}